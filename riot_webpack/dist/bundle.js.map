{"version":3,"sources":["webpack:///bundle.js","webpack:///webpack/bootstrap 4e3972f315b2b02c8a6e","webpack:///./src/index.js","webpack:///./~/riot/riot.js","webpack:///./src/css/tacit.min.css","webpack:///./~/css-loader/lib/css-base.js","webpack:///./src/app.html","webpack:///./~/style-loader/addStyles.js","webpack:///./src/css/tacit.min.css?4899"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","riot","mount","window","loopKeys","expr","ret","val","els","split","brackets","slice","length","trim","key","pos","mkitem","item","_each","dom","parent","add","tag","rendered","splice","tags","remAttr","checksum","template","outerHTML","prev","previousSibling","root","parentNode","one","removeChild","stub","on","items","tmpl","Array","isArray","testsum","JSON","stringify","each","unmount","Object","keys","map","indexOf","newItems","arrFindEquals","oldItems","prev_base","childNodes","i","oldPos","lastIndexOf","nodes","_item","Tag","before","update","insertBefore","parseNamedElements","child_tags","walk","nodeType","child","getTag","getAttribute","tagName","name","cachedTag","push","innerHTML","attributes","attr","test","value","parseExpressions","expressions","addExpr","extra","extend","type","nodeValue","bool","impl","conf","updateOpts","rem_attr","opts","self","toggle","is_mount","evt","loop_dom","observable","this","inherit","mkdom","fn","_id","Date","getTime","Math","random","el","data","init","trigger","firstChild","appendChild","toLowerCase","off","setEventHandler","handler","e","event","which","charCode","keyCode","target","srcElement","currentTarget","preventDefault","returnValue","insertTo","node","attr_name","replace","document","createTextNode","style","display","setAttribute","len","removeAttribute","obj","from","from2","tag_name","root_tag","createElement","nextSibling","arr","filter","_el","Child","prototype","tag_impl","injectStyle","css","head","mountTo","virtual_dom","version","settings","callbacks","events","typed","cb","apply","arguments","args","fns","busy","concat","all","hash","loc","href","parser","path","emit","current","location","win","r","route","arg","exec","addEventListener","attachEvent","orig","s","b","x","RegExp","source","global","extract","Function","join","n","pair","_","k","v","wrap","nonull","re_vars","str","substrings","parts","sub","open","close","start","level","matches","re","cache","html","selector","querySelectorAll","util","undefined","list","toString","result","mediaQuery","alreadyImportedModules","addStylesToDom","styles","options","domStyle","stylesInDom","refs","j","addStyle","listToStyles","newStyles","media","sourceMap","part","createStyleElement","styleElement","getHeadElement","createLinkElement","linkElement","rel","remove","singleton","styleIndex","singletonCounter","singletonElement","applyToSingletonTag","bind","URL","createObjectURL","revokeObjectURL","Blob","btoa","updateLink","applyToTag","newObj","index","styleSheet","cssText","replaceText","cssNode","blob","oldSrc","memoize","memo","isOldIE","navigator","userAgent","getElementsByTagName","Error","newList","mayRemove","textStore","replacement","Boolean","content"],"mappings":"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","file":"bundle.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/dist/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/*!**********************!*\\\n  !*** ./src/index.js ***!\n  \\**********************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(riot) {__webpack_require__(/*! ./css/tacit.min.css */ 6)\n\t__webpack_require__(/*! ./app.html */ 4)\n\triot.mount('app')\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! riot */ 1)))\n\n/***/ },\n/* 1 */\n/*!************************!*\\\n  !*** ./~/riot/riot.js ***!\n  \\************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* Riot v2.0.14, @license MIT, (c) 2015 Muut Inc. + contributors */\n\t\n\t;(function(window) {\n\t  // 'use strict' does not allow us to override the events properties https://github.com/muut/riotjs/blob/dev/lib/tag/update.js#L7-L10\n\t  // it leads to the following error on firefox \"setting a property that has only a getter\"\n\t  //'use strict'\n\t\n\t  var riot = { version: 'v2.0.14', settings: {} }\n\t\n\triot.observable = function(el) {\n\t\n\t  el = el || {}\n\t\n\t  var callbacks = {},\n\t      _id = 0\n\t\n\t  el.on = function(events, fn) {\n\t    if (typeof fn == 'function') {\n\t      fn._id = typeof fn._id == 'undefined' ? _id++ : fn._id\n\t\n\t      events.replace(/\\S+/g, function(name, pos) {\n\t        (callbacks[name] = callbacks[name] || []).push(fn)\n\t        fn.typed = pos > 0\n\t      })\n\t    }\n\t    return el\n\t  }\n\t\n\t  el.off = function(events, fn) {\n\t    if (events == '*') callbacks = {}\n\t    else {\n\t      events.replace(/\\S+/g, function(name) {\n\t        if (fn) {\n\t          var arr = callbacks[name]\n\t          for (var i = 0, cb; (cb = arr && arr[i]); ++i) {\n\t            if (cb._id == fn._id) { arr.splice(i, 1); i-- }\n\t          }\n\t        } else {\n\t          callbacks[name] = []\n\t        }\n\t      })\n\t    }\n\t    return el\n\t  }\n\t\n\t  // only single event supported\n\t  el.one = function(name, fn) {\n\t    function on() {\n\t      el.off(name, on)\n\t      fn.apply(el, arguments)\n\t    }\n\t    return el.on(name, on)\n\t  }\n\t\n\t  el.trigger = function(name) {\n\t    var args = [].slice.call(arguments, 1),\n\t        fns = callbacks[name] || []\n\t\n\t    for (var i = 0, fn; (fn = fns[i]); ++i) {\n\t      if (!fn.busy) {\n\t        fn.busy = 1\n\t        fn.apply(el, fn.typed ? [name].concat(args) : args)\n\t        if (fns[i] !== fn) { i-- }\n\t        fn.busy = 0\n\t      }\n\t    }\n\t\n\t    if (callbacks.all && name != 'all') {\n\t      el.trigger.apply(el, ['all', name].concat(args))\n\t    }\n\t\n\t    return el\n\t  }\n\t\n\t  return el\n\t\n\t}\n\t;(function(riot, evt, window) {\n\t\n\t  // browsers only\n\t  if (!window) return\n\t\n\t  var loc = window.location,\n\t      fns = riot.observable(),\n\t      win = window,\n\t      current\n\t\n\t  function hash() {\n\t    return loc.href.split('#')[1] || ''\n\t  }\n\t\n\t  function parser(path) {\n\t    return path.split('/')\n\t  }\n\t\n\t  function emit(path) {\n\t    if (path.type) path = hash()\n\t\n\t    if (path != current) {\n\t      fns.trigger.apply(null, ['H'].concat(parser(path)))\n\t      current = path\n\t    }\n\t  }\n\t\n\t  var r = riot.route = function(arg) {\n\t    // string\n\t    if (arg[0]) {\n\t      loc.hash = arg\n\t      emit(arg)\n\t\n\t    // function\n\t    } else {\n\t      fns.on('H', arg)\n\t    }\n\t  }\n\t\n\t  r.exec = function(fn) {\n\t    fn.apply(null, parser(hash()))\n\t  }\n\t\n\t  r.parser = function(fn) {\n\t    parser = fn\n\t  }\n\t\n\t  win.addEventListener ? win.addEventListener(evt, emit, false) : win.attachEvent('on' + evt, emit)\n\t\n\t})(riot, 'hashchange', window)\n\t/*\n\t\n\t//// How it works?\n\t\n\t\n\tThree ways:\n\t\n\t1. Expressions: tmpl('{ value }', data).\n\t   Returns the result of evaluated expression as a raw object.\n\t\n\t2. Templates: tmpl('Hi { name } { surname }', data).\n\t   Returns a string with evaluated expressions.\n\t\n\t3. Filters: tmpl('{ show: !done, highlight: active }', data).\n\t   Returns a space separated list of trueish keys (mainly\n\t   used for setting html classes), e.g. \"show highlight\".\n\t\n\t\n\t// Template examples\n\t\n\ttmpl('{ title || \"Untitled\" }', data)\n\ttmpl('Results are { results ? \"ready\" : \"loading\" }', data)\n\ttmpl('Today is { new Date() }', data)\n\ttmpl('{ message.length > 140 && \"Message is too long\" }', data)\n\ttmpl('This item got { Math.round(rating) } stars', data)\n\ttmpl('<h1>{ title }</h1>{ body }', data)\n\t\n\t\n\t// Falsy expressions in templates\n\t\n\tIn templates (as opposed to single expressions) all falsy values\n\texcept zero (undefined/null/false) will default to empty string:\n\t\n\ttmpl('{ undefined } - { false } - { null } - { 0 }', {})\n\t// will return: \" - - - 0\"\n\t\n\t*/\n\t\n\t\n\tvar brackets = (function(orig, s, b) {\n\t  return function(x) {\n\t\n\t    // make sure we use the current setting\n\t    s = riot.settings.brackets || orig\n\t    if (b != s) b = s.split(' ')\n\t\n\t    // if regexp given, rewrite it with current brackets (only if differ from default)\n\t    return x && x.test\n\t      ? s == orig\n\t        ? x : RegExp(x.source\n\t                      .replace(/\\{/g, b[0].replace(/(?=.)/g, '\\\\'))\n\t                      .replace(/\\}/g, b[1].replace(/(?=.)/g, '\\\\')),\n\t                    x.global ? 'g' : '')\n\t\n\t      // else, get specific bracket\n\t      : b[x]\n\t\n\t  }\n\t})('{ }')\n\t\n\t\n\tvar tmpl = (function() {\n\t\n\t  var cache = {},\n\t      re_vars = /(['\"\\/]).*?[^\\\\]\\1|\\.\\w*|\\w*:|\\b(?:(?:new|typeof|in|instanceof) |(?:this|true|false|null|undefined)\\b|function *\\()|([a-z_$]\\w*)/gi\n\t              // [ 1               ][ 2  ][ 3 ][ 4                                                                                  ][ 5       ]\n\t              // find variable names:\n\t              // 1. skip quoted strings and regexps: \"a b\", 'a b', 'a \\'b\\'', /a b/\n\t              // 2. skip object properties: .name\n\t              // 3. skip object literals: name:\n\t              // 4. skip javascript keywords\n\t              // 5. match var name\n\t\n\t  // build a template (or get it from cache), render with data\n\t  return function(str, data) {\n\t    return str && (cache[str] = cache[str] || tmpl(str))(data)\n\t  }\n\t\n\t\n\t  // create a template instance\n\t\n\t  function tmpl(s, p) {\n\t\n\t    // default template string to {}\n\t    s = (s || (brackets(0) + brackets(1)))\n\t\n\t      // temporarily convert \\{ and \\} to a non-character\n\t      .replace(brackets(/\\\\{/g), '\\uFFF0')\n\t      .replace(brackets(/\\\\}/g), '\\uFFF1')\n\t\n\t    // split string to expression and non-expresion parts\n\t    p = split(s, extract(s, brackets(/{/), brackets(/}/)))\n\t\n\t    return new Function('d', 'return ' + (\n\t\n\t      // is it a single expression or a template? i.e. {x} or <b>{x}</b>\n\t      !p[0] && !p[2] && !p[3]\n\t\n\t        // if expression, evaluate it\n\t        ? expr(p[1])\n\t\n\t        // if template, evaluate all expressions in it\n\t        : '[' + p.map(function(s, i) {\n\t\n\t            // is it an expression or a string (every second part is an expression)\n\t          return i % 2\n\t\n\t              // evaluate the expressions\n\t              ? expr(s, true)\n\t\n\t              // process string parts of the template:\n\t              : '\"' + s\n\t\n\t                  // preserve new lines\n\t                  .replace(/\\n/g, '\\\\n')\n\t\n\t                  // escape quotes\n\t                  .replace(/\"/g, '\\\\\"')\n\t\n\t                + '\"'\n\t\n\t        }).join(',') + '].join(\"\")'\n\t      )\n\t\n\t      // bring escaped { and } back\n\t      .replace(/\\uFFF0/g, brackets(0))\n\t      .replace(/\\uFFF1/g, brackets(1))\n\t\n\t    + ';')\n\t\n\t  }\n\t\n\t\n\t  // parse { ... } expression\n\t\n\t  function expr(s, n) {\n\t    s = s\n\t\n\t      // convert new lines to spaces\n\t      .replace(/\\n/g, ' ')\n\t\n\t      // trim whitespace, brackets, strip comments\n\t      .replace(brackets(/^[{ ]+|[ }]+$|\\/\\*.+?\\*\\//g), '')\n\t\n\t    // is it an object literal? i.e. { key : value }\n\t    return /^\\s*[\\w- \"']+ *:/.test(s)\n\t\n\t      // if object literal, return trueish keys\n\t      // e.g.: { show: isOpen(), done: item.done } -> \"show done\"\n\t      ? '[' +\n\t\n\t          // extract key:val pairs, ignoring any nested objects\n\t          extract(s,\n\t\n\t              // name part: name:, \"name\":, 'name':, name :\n\t              /[\"' ]*[\\w- ]+[\"' ]*:/,\n\t\n\t              // expression part: everything upto a comma followed by a name (see above) or end of line\n\t              /,(?=[\"' ]*[\\w- ]+[\"' ]*:)|}|$/\n\t              ).map(function(pair) {\n\t\n\t                // get key, val parts\n\t                return pair.replace(/^[ \"']*(.+?)[ \"']*: *(.+?),? *$/, function(_, k, v) {\n\t\n\t                  // wrap all conditional parts to ignore errors\n\t                  return v.replace(/[^&|=!><]+/g, wrap) + '?\"' + k + '\":\"\",'\n\t\n\t                })\n\t\n\t              }).join('')\n\t\n\t        + '].join(\" \").trim()'\n\t\n\t      // if js expression, evaluate as javascript\n\t      : wrap(s, n)\n\t\n\t  }\n\t\n\t\n\t  // execute js w/o breaking on errors or undefined vars\n\t\n\t  function wrap(s, nonull) {\n\t    s = s.trim()\n\t    return !s ? '' : '(function(v){try{v='\n\t\n\t        // prefix vars (name => data.name)\n\t        + (s.replace(re_vars, function(s, _, v) { return v ? '(d.'+v+'===undefined?'+(typeof window == 'undefined' ? 'global.' : 'window.')+v+':d.'+v+')' : s })\n\t\n\t          // break the expression if its empty (resulting in undefined value)\n\t          || 'x')\n\t\n\t      + '}finally{return '\n\t\n\t        // default to empty string for falsy values except zero\n\t        + (nonull === true ? '!v&&v!==0?\"\":v' : 'v')\n\t\n\t      + '}}).call(d)'\n\t  }\n\t\n\t\n\t  // split string by an array of substrings\n\t\n\t  function split(str, substrings) {\n\t    var parts = []\n\t    substrings.map(function(sub, i) {\n\t\n\t      // push matched expression and part before it\n\t      i = str.indexOf(sub)\n\t      parts.push(str.slice(0, i), sub)\n\t      str = str.slice(i + sub.length)\n\t    })\n\t\n\t    // push the remaining part\n\t    return parts.concat(str)\n\t  }\n\t\n\t\n\t  // match strings between opening and closing regexp, skipping any inner/nested matches\n\t\n\t  function extract(str, open, close) {\n\t\n\t    var start,\n\t        level = 0,\n\t        matches = [],\n\t        re = new RegExp('('+open.source+')|('+close.source+')', 'g')\n\t\n\t    str.replace(re, function(_, open, close, pos) {\n\t\n\t      // if outer inner bracket, mark position\n\t      if(!level && open) start = pos\n\t\n\t      // in(de)crease bracket level\n\t      level += open ? 1 : -1\n\t\n\t      // if outer closing bracket, grab the match\n\t      if(!level && close != null) matches.push(str.slice(start, pos+close.length))\n\t\n\t    })\n\t\n\t    return matches\n\t  }\n\t\n\t})()\n\t\n\t// { key, i in items} -> { key, i, items }\n\tfunction loopKeys(expr) {\n\t  var ret = { val: expr },\n\t      els = expr.split(/\\s+in\\s+/)\n\t\n\t  if (els[1]) {\n\t    ret.val = brackets(0) + els[1]\n\t    els = els[0].slice(brackets(0).length).trim().split(/,\\s*/)\n\t    ret.key = els[0]\n\t    ret.pos = els[1]\n\t  }\n\t\n\t  return ret\n\t}\n\t\n\tfunction mkitem(expr, key, val) {\n\t  var item = {}\n\t  item[expr.key] = key\n\t  if (expr.pos) item[expr.pos] = val\n\t  return item\n\t}\n\t\n\t\n\t/* Beware: heavy stuff */\n\tfunction _each(dom, parent, expr) {\n\t\n\t  remAttr(dom, 'each')\n\t\n\t  var template = dom.outerHTML,\n\t      prev = dom.previousSibling,\n\t      root = dom.parentNode,\n\t      rendered = [],\n\t      tags = [],\n\t      checksum\n\t\n\t  expr = loopKeys(expr)\n\t\n\t  function add(pos, item, tag) {\n\t    rendered.splice(pos, 0, item)\n\t    tags.splice(pos, 0, tag)\n\t  }\n\t\n\t  // clean template code\n\t  parent.one('update', function() {\n\t    root.removeChild(dom)\n\t\n\t  }).one('premount', function() {\n\t    if (root.stub) root = parent.root\n\t\n\t  }).on('update', function() {\n\t\n\t    var items = tmpl(expr.val, parent)\n\t    if (!items) return\n\t\n\t    // object loop. any changes cause full redraw\n\t    if (!Array.isArray(items)) {\n\t      var testsum = JSON.stringify(items)\n\t      if (testsum == checksum) return\n\t      checksum = testsum\n\t\n\t      // clear old items\n\t      each(tags, function(tag) { tag.unmount() })\n\t      rendered = []\n\t      tags = []\n\t\n\t      items = Object.keys(items).map(function(key) {\n\t        return mkitem(expr, key, items[key])\n\t      })\n\t\n\t    }\n\t\n\t    // unmount redundant\n\t    each(rendered, function(item) {\n\t      if (item instanceof Object) {\n\t        // skip existing items\n\t        if (items.indexOf(item) > -1) {\n\t          return\n\t        }\n\t      } else {\n\t        // find all non-objects\n\t        var newItems = arrFindEquals(items, item),\n\t            oldItems = arrFindEquals(rendered, item)\n\t\n\t        // if more or equal amount, no need to remove\n\t        if (newItems.length >= oldItems.length) {\n\t          return\n\t        }\n\t      }\n\t      var pos = rendered.indexOf(item),\n\t          tag = tags[pos]\n\t\n\t      if (tag) {\n\t        tag.unmount()\n\t        rendered.splice(pos, 1)\n\t        tags.splice(pos, 1)\n\t        // to let \"each\" know that this item is removed\n\t        return false\n\t      }\n\t\n\t    })\n\t\n\t    // mount new / reorder\n\t    var prev_base = [].indexOf.call(root.childNodes, prev) + 1\n\t    each(items, function(item, i) {\n\t\n\t      // start index search from position based on the current i\n\t      var pos = items.indexOf(item, i),\n\t          oldPos = rendered.indexOf(item, i)\n\t\n\t      // if not found, search backwards from current i position\n\t      pos < 0 && (pos = items.lastIndexOf(item, i))\n\t      oldPos < 0 && (oldPos = rendered.lastIndexOf(item, i))\n\t\n\t      if (!(item instanceof Object)) {\n\t        // find all non-objects\n\t        var newItems = arrFindEquals(items, item),\n\t            oldItems = arrFindEquals(rendered, item)\n\t\n\t        // if more, should mount one new\n\t        if (newItems.length > oldItems.length) {\n\t          oldPos = -1\n\t        }\n\t      }\n\t\n\t      // mount new\n\t      var nodes = root.childNodes\n\t      if (oldPos < 0) {\n\t        if (!checksum && expr.key) var _item = mkitem(expr, item, pos)\n\t\n\t        var tag = new Tag({ tmpl: template }, {\n\t          before: nodes[prev_base + pos],\n\t          parent: parent,\n\t          root: root,\n\t          item: _item || item\n\t        })\n\t\n\t        tag.mount()\n\t\n\t        add(pos, item, tag)\n\t        return true\n\t      }\n\t\n\t      // change pos value\n\t      if (expr.pos && tags[oldPos][expr.pos] != pos) {\n\t        tags[oldPos].one('update', function(item) {\n\t          item[expr.pos] = pos\n\t        })\n\t        tags[oldPos].update()\n\t      }\n\t\n\t      // reorder\n\t      if (pos != oldPos) {\n\t        root.insertBefore(nodes[prev_base + oldPos], nodes[prev_base + (pos > oldPos ? pos + 1 : pos)])\n\t        return add(pos, rendered.splice(oldPos, 1)[0], tags.splice(oldPos, 1)[0])\n\t      }\n\t\n\t    })\n\t\n\t    rendered = items.slice()\n\t\n\t  })\n\t\n\t}\n\t\n\t\n\tfunction parseNamedElements(root, parent, child_tags) {\n\t\n\t  walk(root, function(dom) {\n\t    if (dom.nodeType == 1) {\n\t\n\t      // custom child tag\n\t      var child = getTag(dom)\n\t\n\t      if (child && !dom.getAttribute('each')) {\n\t        var tag = new Tag(child, { root: dom, parent: parent }),\n\t            tagName = dom.getAttribute('name') || child.name,\n\t            cachedTag = parent.tags[tagName]\n\t\n\t        // if there are multiple children tags having the same name\n\t        if (cachedTag) {\n\t          // if the parent tags property is not yet an array\n\t          // create it adding the first cached tag\n\t          if (!Array.isArray(cachedTag))\n\t            parent.tags[tagName] = [cachedTag]\n\t          // add the new nested tag to the array\n\t          parent.tags[tagName].push(tag)\n\t        } else {\n\t          parent.tags[tagName] = tag\n\t        }\n\t\n\t        // empty the child node once we got its template\n\t        // to avoid that its children get compiled multiple times\n\t        dom.innerHTML = ''\n\t        child_tags.push(tag)\n\t      }\n\t\n\t      each(dom.attributes, function(attr) {\n\t        if (/^(name|id)$/.test(attr.name)) parent[attr.value] = dom\n\t      })\n\t    }\n\t\n\t  })\n\t\n\t}\n\t\n\tfunction parseExpressions(root, tag, expressions) {\n\t\n\t  function addExpr(dom, val, extra) {\n\t    if (val.indexOf(brackets(0)) >= 0) {\n\t      var expr = { dom: dom, expr: val }\n\t      expressions.push(extend(expr, extra))\n\t    }\n\t  }\n\t\n\t  walk(root, function(dom) {\n\t    var type = dom.nodeType\n\t\n\t    // text node\n\t    if (type == 3 && dom.parentNode.tagName != 'STYLE') addExpr(dom, dom.nodeValue)\n\t    if (type != 1) return\n\t\n\t    /* element */\n\t\n\t    // loop\n\t    var attr = dom.getAttribute('each')\n\t    if (attr) { _each(dom, tag, attr); return false }\n\t\n\t    // attribute expressions\n\t    each(dom.attributes, function(attr) {\n\t      var name = attr.name,\n\t          bool = name.split('__')[1]\n\t\n\t      addExpr(dom, attr.value, { attr: bool || name, bool: bool })\n\t      if (bool) { remAttr(dom, name); return false }\n\t\n\t    })\n\t\n\t    // skip custom tags\n\t    if (getTag(dom)) return false\n\t\n\t  })\n\t\n\t}\n\tfunction Tag(impl, conf) {\n\t\n\t  var self = riot.observable(this),\n\t      opts = inherit(conf.opts) || {},\n\t      dom = mkdom(impl.tmpl),\n\t      parent = conf.parent,\n\t      expressions = [],\n\t      child_tags = [],\n\t      root = conf.root,\n\t      item = conf.item,\n\t      fn = impl.fn,\n\t      attr = {},\n\t      loop_dom\n\t\n\t  if (fn && root.riot) return\n\t  root.riot = true\n\t\n\t  // create a unique id to this tag\n\t  // it could be handy to use it also to improve the virtual dom rendering speed\n\t  this._id = ~~(new Date().getTime() * Math.random())\n\t\n\t  extend(this, { parent: parent, root: root, opts: opts, tags: {} }, item)\n\t\n\t  // grab attributes\n\t  each(root.attributes, function(el) {\n\t    attr[el.name] = el.value\n\t  })\n\t\n\t  // options\n\t  function updateOpts(rem_attr) {\n\t    each(Object.keys(attr), function(name) {\n\t      opts[name] = tmpl(attr[name], parent || self)\n\t    })\n\t  }\n\t\n\t  this.update = function(data, init) {\n\t    extend(self, data, item)\n\t    updateOpts()\n\t    self.trigger('update', item)\n\t    update(expressions, self, item)\n\t    self.trigger('updated')\n\t  }\n\t\n\t  this.mount = function() {\n\t\n\t    updateOpts()\n\t\n\t    // initialiation\n\t    fn && fn.call(self, opts)\n\t\n\t    toggle(true)\n\t\n\t    // parse layout after init. fn may calculate args for nested custom tags\n\t    parseExpressions(dom, self, expressions)\n\t\n\t    self.update()\n\t\n\t    // internal use only, fixes #403\n\t    self.trigger('premount')\n\t\n\t    if (fn) {\n\t      while (dom.firstChild) root.appendChild(dom.firstChild)\n\t\n\t    } else {\n\t      loop_dom = dom.firstChild\n\t      root.insertBefore(loop_dom, conf.before || null) // null needed for IE8\n\t    }\n\t\n\t    if (root.stub) self.root = root = parent.root\n\t    self.trigger('mount')\n\t\n\t  }\n\t\n\t\n\t  this.unmount = function() {\n\t    var el = fn ? root : loop_dom,\n\t        p = el.parentNode,\n\t        // detect the tag name\n\t        tagName = root.tagName.toLowerCase()\n\t\n\t    if (p) {\n\t\n\t      if (parent) {\n\t        // remove this tag from the parent tags object\n\t        // if there are multiple nested tags with same name..\n\t        // remove this element form the array\n\t        if (Array.isArray(parent.tags[tagName])) {\n\t          each(parent.tags[tagName], function(tag, i) {\n\t            if (tag._id == self._id)\n\t              parent.tags[tagName].splice(i, 1)\n\t          })\n\t        } else\n\t          // otherwise just delete the tag instance\n\t          delete parent.tags[tagName]\n\t\n\t        p.removeChild(el)\n\t      } else {\n\t        while (el.firstChild) el.removeChild(el.firstChild)\n\t        p.removeChild(el)\n\t      }\n\t\n\t    }\n\t\n\t    self.trigger('unmount')\n\t    toggle()\n\t    self.off('*')\n\t    delete root.riot\n\t\n\t  }\n\t\n\t  function toggle(is_mount) {\n\t\n\t    // mount/unmount children\n\t    each(child_tags, function(child) { child[is_mount ? 'mount' : 'unmount']() })\n\t\n\t    // listen/unlisten parent (events flow one way from parent to children)\n\t    if (parent) {\n\t      var evt = is_mount ? 'on' : 'off'\n\t      parent[evt]('update', self.update)[evt]('unmount', self.unmount)\n\t    }\n\t  }\n\t\n\t  // named elements available for fn\n\t  parseNamedElements(dom, this, child_tags)\n\t\n\t\n\t}\n\t\n\tfunction setEventHandler(name, handler, dom, tag, item) {\n\t\n\t  dom[name] = function(e) {\n\t\n\t    // cross browser event fix\n\t    e = e || window.event\n\t    e.which = e.which || e.charCode || e.keyCode\n\t    e.target = e.target || e.srcElement\n\t    e.currentTarget = dom\n\t    e.item = item\n\t\n\t    // prevent default behaviour (by default)\n\t    if (handler.call(tag, e) !== true && !/radio|check/.test(dom.type)) {\n\t      e.preventDefault && e.preventDefault()\n\t      e.returnValue = false\n\t    }\n\t\n\t    var el = item ? tag.parent : tag\n\t    el.update()\n\t\n\t  }\n\t\n\t}\n\t\n\t// used by if- attribute\n\tfunction insertTo(root, node, before) {\n\t  if (root) {\n\t    root.insertBefore(before, node)\n\t    root.removeChild(node)\n\t  }\n\t}\n\t\n\t// item = currently looped item\n\tfunction update(expressions, tag, item) {\n\t\n\t  each(expressions, function(expr) {\n\t\n\t    var dom = expr.dom,\n\t        attr_name = expr.attr,\n\t        value = tmpl(expr.expr, tag),\n\t        parent = expr.dom.parentNode\n\t\n\t    if (value == null) value = ''\n\t\n\t    // leave out riot- prefixes from strings inside textarea\n\t    if (parent && parent.tagName == 'TEXTAREA') value = value.replace(/riot-/g, '')\n\t\n\t    // no change\n\t    if (expr.value === value) return\n\t    expr.value = value\n\t\n\t    // text node\n\t    if (!attr_name) return dom.nodeValue = value\n\t\n\t    // remove original attribute\n\t    remAttr(dom, attr_name)\n\t\n\t    // event handler\n\t    if (typeof value == 'function') {\n\t      setEventHandler(attr_name, value, dom, tag, item)\n\t\n\t    // if- conditional\n\t    } else if (attr_name == 'if') {\n\t      var stub = expr.stub\n\t\n\t      // add to DOM\n\t      if (value) {\n\t        stub && insertTo(stub.parentNode, stub, dom)\n\t\n\t      // remove from DOM\n\t      } else {\n\t        stub = expr.stub = stub || document.createTextNode('')\n\t        insertTo(dom.parentNode, dom, stub)\n\t      }\n\t\n\t    // show / hide\n\t    } else if (/^(show|hide)$/.test(attr_name)) {\n\t      if (attr_name == 'hide') value = !value\n\t      dom.style.display = value ? '' : 'none'\n\t\n\t    // field value\n\t    } else if (attr_name == 'value') {\n\t      dom.value = value\n\t\n\t    // <img src=\"{ expr }\">\n\t    } else if (attr_name.slice(0, 5) == 'riot-') {\n\t      attr_name = attr_name.slice(5)\n\t      value ? dom.setAttribute(attr_name, value) : remAttr(dom, attr_name)\n\t\n\t    } else {\n\t      if (expr.bool) {\n\t        dom[attr_name] = value\n\t        if (!value) return\n\t        value = attr_name\n\t      }\n\t\n\t      if (typeof value != 'object') dom.setAttribute(attr_name, value)\n\t\n\t    }\n\t\n\t  })\n\t\n\t}\n\tfunction each(els, fn) {\n\t  for (var i = 0, len = (els || []).length, el; i < len; i++) {\n\t    el = els[i]\n\t    // return false -> remove current item during loop\n\t    if (el != null && fn(el, i) === false) i--\n\t  }\n\t  return els\n\t}\n\t\n\tfunction remAttr(dom, name) {\n\t  dom.removeAttribute(name)\n\t}\n\t\n\t// max 2 from objects allowed\n\tfunction extend(obj, from, from2) {\n\t  from && each(Object.keys(from), function(key) {\n\t    obj[key] = from[key]\n\t  })\n\t  return from2 ? extend(obj, from2) : obj\n\t}\n\t\n\tfunction mkdom(template) {\n\t  var tag_name = template.trim().slice(1, 3).toLowerCase(),\n\t      root_tag = /td|th/.test(tag_name) ? 'tr' : tag_name == 'tr' ? 'tbody' : 'div',\n\t      el = document.createElement(root_tag)\n\t\n\t  el.stub = true\n\t  el.innerHTML = template\n\t  return el\n\t}\n\t\n\tfunction walk(dom, fn) {\n\t  if (dom) {\n\t    if (fn(dom) === false) walk(dom.nextSibling, fn)\n\t    else {\n\t      dom = dom.firstChild\n\t\n\t      while (dom) {\n\t        walk(dom, fn)\n\t        dom = dom.nextSibling\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tfunction arrDiff(arr1, arr2) {\n\t  return arr1.filter(function(el) {\n\t    return arr2.indexOf(el) < 0\n\t  })\n\t}\n\t\n\tfunction arrFindEquals(arr, el) {\n\t  return arr.filter(function (_el) {\n\t    return _el === el\n\t  })\n\t}\n\t\n\tfunction inherit(parent) {\n\t  function Child() {}\n\t  Child.prototype = parent\n\t  return new Child()\n\t}\n\t\n\t/*\n\t Virtual dom is an array of custom tags on the document.\n\t Updates and unmounts propagate downwards from parent to children.\n\t*/\n\t\n\tvar virtual_dom = [],\n\t    tag_impl = {}\n\t\n\t\n\tfunction getTag(dom) {\n\t  return tag_impl[dom.tagName.toLowerCase()]\n\t}\n\t\n\tfunction injectStyle(css) {\n\t  var node = document.createElement('style')\n\t  node.innerHTML = css\n\t  document.head.appendChild(node)\n\t}\n\t\n\tfunction mountTo(root, tagName, opts) {\n\t  var tag = tag_impl[tagName]\n\t\n\t  if (tag && root) tag = new Tag(tag, { root: root, opts: opts })\n\t\n\t  if (tag && tag.mount) {\n\t    tag.mount()\n\t    virtual_dom.push(tag)\n\t    return tag.on('unmount', function() {\n\t      virtual_dom.splice(virtual_dom.indexOf(tag), 1)\n\t    })\n\t  }\n\t\n\t}\n\t\n\triot.tag = function(name, html, css, fn) {\n\t  if (typeof css == 'function') fn = css\n\t  else if (css) injectStyle(css)\n\t  tag_impl[name] = { name: name, tmpl: html, fn: fn }\n\t  return name\n\t}\n\t\n\triot.mount = function(selector, tagName, opts) {\n\t  if (selector == '*') selector = Object.keys(tag_impl).join(', ')\n\t  if (typeof tagName == 'object') { opts = tagName; tagName = 0 }\n\t\n\t  var tags = []\n\t\n\t  function push(root) {\n\t    var name = tagName || root.tagName.toLowerCase(),\n\t        tag = mountTo(root, name, opts)\n\t\n\t    if (tag) tags.push(tag)\n\t  }\n\t\n\t  // DOM node\n\t  if (selector.tagName) {\n\t    push(selector)\n\t    return tags[0]\n\t\n\t  // selector or NodeList\n\t  } else {\n\t    each(typeof selector == 'string' ? document.querySelectorAll(selector) : selector, push)\n\t    return tags\n\t  }\n\t\n\t}\n\t\n\t// update everything\n\triot.update = function() {\n\t  return each(virtual_dom, function(tag) {\n\t    tag.update()\n\t  })\n\t}\n\t\n\t// @deprecated\n\triot.mountTo = riot.mount\n\t\n\t\n\t\n\t  // share methods for other riot parts, e.g. compiler\n\t  riot.util = { brackets: brackets, tmpl: tmpl }\n\t\n\t  // support CommonJS, AMD & browser\n\t  if (true)\n\t    module.exports = riot\n\t  else if (typeof define === 'function' && define.amd)\n\t    define(function() { return riot })\n\t  else\n\t    window.riot = riot\n\t\n\t})(typeof window != 'undefined' ? window : undefined);\n\n\n/***/ },\n/* 2 */\n/*!**********************************************!*\\\n  !*** ./~/css-loader!./src/css/tacit.min.css ***!\n  \\**********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(/*! ./../../~/css-loader/lib/css-base.js */ 3)();\n\texports.push([module.id, \"label,table{display:block}h1,h4,h5,h6{font-size:36px}b,h1,strong{font-weight:500}*,pre code{line-height:29.7px}*,h3{font-size:18px}*,pre code{padding:0;border:0}section,table{max-width:100%}footer,h1,h4,h5,h6{margin-top:36px}th{font-weight:600}td,th{border-bottom:1.08px solid #ccc;padding:14.85px 18px}thead th{border-bottom-width:2.16px;padding-bottom:6.3px}table{overflow-x:auto}button,input,select,textarea{display:block;padding:9.9px}label{margin-bottom:14.76px}button,input[type=submit],input[type=reset]{background:#b3b3b3;border-radius:3.6px;color:#fff;cursor:pointer;display:inline;margin-bottom:18px;margin-right:7.2px;padding:6.53px 23.4px;text-align:center}button:hover,input[type=submit]:hover,input[type=reset]:hover{background:#a6a6a6;color:#bfbfbf}button[type=submit],input[type=submit]{background:#367ac3;color:#fff}button[type=submit]:hover,input[type=submit]:hover{background:#255587;color:#bfbfbf}input[type=date],input[type=month],input[type=color],input[type=time],input[type=search],input[type=range],input[type=file],input[type=datetime-local],input[type=text],input[type=password],input[type=email],input[type=url],input[type=phone],input[type=tel],input[type=number],input[type=datetime],select,textarea{border:1px solid #ccc;margin-bottom:18px;padding:5.4px 6.3px}input[type=checkbox]{float:left;line-height:36px;margin-right:9px;margin-top:8.1px}code,kbd,output,pre,samp,var{font-family:Menlo,Monaco,Consolas,\\\"Courier New\\\",monospace;font-size:16.2px}pre{border-left:1.8px solid #96bbe2;line-height:25.2px;margin-top:29.7px;overflow:auto;padding-left:18px}pre code{background:0 0}code{background:#ededed;border:1.8px solid #ccc;border-radius:3.6px;display:inline-block;line-height:18px;padding:3px 6px 2px}h1,h2,h3,h4,h5,h6{color:#000}h1{margin-bottom:18px}h2{font-size:25.2px;font-weight:400;margin-bottom:18px;margin-top:27px}h3{margin-bottom:18px;margin-top:21.6px}h4,h5,h6{margin-bottom:18px}a{color:#367ac3;text-decoration:none}a:hover{text-decoration:underline}hr{border-bottom:1px solid #ccc}small{font-size:15.3px}em,i{font-style:italic}*{border-collapse:separate;border-spacing:0;box-sizing:border-box;font-family:\\\"Helvetica Neue\\\",Helvetica,Arial,sans-serif;font-stretch:normal;font-style:normal;font-weight:300;margin:0;outline:0;text-align:left;vertical-align:baseline}nav,nav ul{text-align:center}body{background:#f5f5f5;color:#1a1a1a;padding:36px}address,blockquote,dl,fieldset,figure,form,hr,ol,p,pre,table,ul{margin-bottom:29.7px}section{margin-left:auto;margin-right:auto;width:900px}article{background:#fff;border:1.8px solid #d9d9d9;border-radius:7.2px;padding:43.2px}header{margin-bottom:36px}nav ul{list-style:none}nav ul li{display:inline;margin-left:9px;margin-right:9px}@media (max-width:767px){article,body{padding:18px}article{border-radius:0;margin:-18px}input,select,textarea{max-width:100%}fieldset{min-width:0}@-moz-document url-prefix(){fieldset{display:table-cell}}section{width:auto}}\", \"\"]);\n\n/***/ },\n/* 3 */\n/*!**************************************!*\\\n  !*** ./~/css-loader/lib/css-base.js ***!\n  \\**************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\r\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\t\tAuthor Tobias Koppers @sokra\r\n\t*/\r\n\t// css base code, injected by the css-loader\r\n\t// \r\n\tmodule.exports = function() {\r\n\t\tvar list = [];\r\n\t\r\n\t\t// return the list of modules as css string\r\n\t\tlist.toString = function toString() {\r\n\t\t\tvar result = [];\r\n\t\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\t\tvar item = this[i];\r\n\t\t\t\tif(item[2]) {\r\n\t\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tresult.push(item[1]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn result.join(\"\");\r\n\t\t};\r\n\t\r\n\t\t// import a list of modules into the list\r\n\t\tlist.i = function(modules, mediaQuery) {\r\n\t\t\tif(typeof modules === \"string\")\r\n\t\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\t\tvar alreadyImportedModules = {};\r\n\t\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\t\tvar id = this[i][0];\r\n\t\t\t\tif(typeof id === \"number\")\r\n\t\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t\t}\r\n\t\t\tfor(var i = 0; i < modules.length; i++) {\r\n\t\t\t\tvar item = modules[i];\r\n\t\t\t\t// skip already imported module\r\n\t\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlist.push(item);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn list;\r\n\t};\r\n\n\n/***/ },\n/* 4 */\n/*!**********************!*\\\n  !*** ./src/app.html ***!\n  \\**********************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(riot) {riot.tag('app', '<div>test riotjs12!</div>', function(opts) {\n\t\n\t\n\t});\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! riot */ 1)))\n\n/***/ },\n/* 5 */\n/*!*************************************!*\\\n  !*** ./~/style-loader/addStyles.js ***!\n  \\*************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\r\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\t\tAuthor Tobias Koppers @sokra\r\n\t*/\r\n\tvar stylesInDom = {},\r\n\t\tmemoize = function(fn) {\r\n\t\t\tvar memo;\r\n\t\t\treturn function () {\r\n\t\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\r\n\t\t\t\treturn memo;\r\n\t\t\t};\r\n\t\t},\r\n\t\tisOldIE = memoize(function() {\r\n\t\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\r\n\t\t}),\r\n\t\tgetHeadElement = memoize(function () {\r\n\t\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\r\n\t\t}),\r\n\t\tsingletonElement = null,\r\n\t\tsingletonCounter = 0;\r\n\t\r\n\tmodule.exports = function(list, options) {\r\n\t\tif(true) {\r\n\t\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\r\n\t\t}\r\n\t\r\n\t\toptions = options || {};\r\n\t\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\r\n\t\t// tags it will allow on a page\r\n\t\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\r\n\t\r\n\t\tvar styles = listToStyles(list);\r\n\t\taddStylesToDom(styles, options);\r\n\t\r\n\t\treturn function update(newList) {\r\n\t\t\tvar mayRemove = [];\r\n\t\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\t\tvar item = styles[i];\r\n\t\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\t\tdomStyle.refs--;\r\n\t\t\t\tmayRemove.push(domStyle);\r\n\t\t\t}\r\n\t\t\tif(newList) {\r\n\t\t\t\tvar newStyles = listToStyles(newList);\r\n\t\t\t\taddStylesToDom(newStyles, options);\r\n\t\t\t}\r\n\t\t\tfor(var i = 0; i < mayRemove.length; i++) {\r\n\t\t\t\tvar domStyle = mayRemove[i];\r\n\t\t\t\tif(domStyle.refs === 0) {\r\n\t\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\r\n\t\t\t\t\t\tdomStyle.parts[j]();\r\n\t\t\t\t\tdelete stylesInDom[domStyle.id];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\t\r\n\tfunction addStylesToDom(styles, options) {\r\n\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\tvar item = styles[i];\r\n\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\tif(domStyle) {\r\n\t\t\t\tdomStyle.refs++;\r\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\r\n\t\t\t\t\tdomStyle.parts[j](item.parts[j]);\r\n\t\t\t\t}\r\n\t\t\t\tfor(; j < item.parts.length; j++) {\r\n\t\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tvar parts = [];\r\n\t\t\t\tfor(var j = 0; j < item.parts.length; j++) {\r\n\t\t\t\t\tparts.push(addStyle(item.parts[j], options));\r\n\t\t\t\t}\r\n\t\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction listToStyles(list) {\r\n\t\tvar styles = [];\r\n\t\tvar newStyles = {};\r\n\t\tfor(var i = 0; i < list.length; i++) {\r\n\t\t\tvar item = list[i];\r\n\t\t\tvar id = item[0];\r\n\t\t\tvar css = item[1];\r\n\t\t\tvar media = item[2];\r\n\t\t\tvar sourceMap = item[3];\r\n\t\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\r\n\t\t\tif(!newStyles[id])\r\n\t\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\r\n\t\t\telse\r\n\t\t\t\tnewStyles[id].parts.push(part);\r\n\t\t}\r\n\t\treturn styles;\r\n\t}\r\n\t\r\n\tfunction createStyleElement() {\r\n\t\tvar styleElement = document.createElement(\"style\");\r\n\t\tvar head = getHeadElement();\r\n\t\tstyleElement.type = \"text/css\";\r\n\t\thead.appendChild(styleElement);\r\n\t\treturn styleElement;\r\n\t}\r\n\t\r\n\tfunction createLinkElement() {\r\n\t\tvar linkElement = document.createElement(\"link\");\r\n\t\tvar head = getHeadElement();\r\n\t\tlinkElement.rel = \"stylesheet\";\r\n\t\thead.appendChild(linkElement);\r\n\t\treturn linkElement;\r\n\t}\r\n\t\r\n\tfunction addStyle(obj, options) {\r\n\t\tvar styleElement, update, remove;\r\n\t\r\n\t\tif (options.singleton) {\r\n\t\t\tvar styleIndex = singletonCounter++;\r\n\t\t\tstyleElement = singletonElement || (singletonElement = createStyleElement());\r\n\t\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\r\n\t\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\r\n\t\t} else if(obj.sourceMap &&\r\n\t\t\ttypeof URL === \"function\" &&\r\n\t\t\ttypeof URL.createObjectURL === \"function\" &&\r\n\t\t\ttypeof URL.revokeObjectURL === \"function\" &&\r\n\t\t\ttypeof Blob === \"function\" &&\r\n\t\t\ttypeof btoa === \"function\") {\r\n\t\t\tstyleElement = createLinkElement();\r\n\t\t\tupdate = updateLink.bind(null, styleElement);\r\n\t\t\tremove = function() {\r\n\t\t\t\tstyleElement.parentNode.removeChild(styleElement);\r\n\t\t\t\tif(styleElement.href)\r\n\t\t\t\t\tURL.revokeObjectURL(styleElement.href);\r\n\t\t\t};\r\n\t\t} else {\r\n\t\t\tstyleElement = createStyleElement();\r\n\t\t\tupdate = applyToTag.bind(null, styleElement);\r\n\t\t\tremove = function() {\r\n\t\t\t\tstyleElement.parentNode.removeChild(styleElement);\r\n\t\t\t};\r\n\t\t}\r\n\t\r\n\t\tupdate(obj);\r\n\t\r\n\t\treturn function updateStyle(newObj) {\r\n\t\t\tif(newObj) {\r\n\t\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\r\n\t\t\t\t\treturn;\r\n\t\t\t\tupdate(obj = newObj);\r\n\t\t\t} else {\r\n\t\t\t\tremove();\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\t\r\n\tvar replaceText = (function () {\r\n\t\tvar textStore = [];\r\n\t\r\n\t\treturn function (index, replacement) {\r\n\t\t\ttextStore[index] = replacement;\r\n\t\t\treturn textStore.filter(Boolean).join('\\n');\r\n\t\t};\r\n\t})();\r\n\t\r\n\tfunction applyToSingletonTag(styleElement, index, remove, obj) {\r\n\t\tvar css = remove ? \"\" : obj.css;\r\n\t\r\n\t\tif (styleElement.styleSheet) {\r\n\t\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\r\n\t\t} else {\r\n\t\t\tvar cssNode = document.createTextNode(css);\r\n\t\t\tvar childNodes = styleElement.childNodes;\r\n\t\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\r\n\t\t\tif (childNodes.length) {\r\n\t\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\r\n\t\t\t} else {\r\n\t\t\t\tstyleElement.appendChild(cssNode);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction applyToTag(styleElement, obj) {\r\n\t\tvar css = obj.css;\r\n\t\tvar media = obj.media;\r\n\t\tvar sourceMap = obj.sourceMap;\r\n\t\r\n\t\tif(media) {\r\n\t\t\tstyleElement.setAttribute(\"media\", media)\r\n\t\t}\r\n\t\r\n\t\tif(styleElement.styleSheet) {\r\n\t\t\tstyleElement.styleSheet.cssText = css;\r\n\t\t} else {\r\n\t\t\twhile(styleElement.firstChild) {\r\n\t\t\t\tstyleElement.removeChild(styleElement.firstChild);\r\n\t\t\t}\r\n\t\t\tstyleElement.appendChild(document.createTextNode(css));\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction updateLink(linkElement, obj) {\r\n\t\tvar css = obj.css;\r\n\t\tvar media = obj.media;\r\n\t\tvar sourceMap = obj.sourceMap;\r\n\t\r\n\t\tif(sourceMap) {\r\n\t\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(JSON.stringify(sourceMap)) + \" */\";\r\n\t\t}\r\n\t\r\n\t\tvar blob = new Blob([css], { type: \"text/css\" });\r\n\t\r\n\t\tvar oldSrc = linkElement.href;\r\n\t\r\n\t\tlinkElement.href = URL.createObjectURL(blob);\r\n\t\r\n\t\tif(oldSrc)\r\n\t\t\tURL.revokeObjectURL(oldSrc);\r\n\t}\r\n\n\n/***/ },\n/* 6 */\n/*!*******************************!*\\\n  !*** ./src/css/tacit.min.css ***!\n  \\*******************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(/*! !./../../~/css-loader!./tacit.min.css */ 2);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(/*! ./../../~/style-loader/addStyles.js */ 5)(content, {});\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tmodule.hot.accept(\"!!./../../node_modules/css-loader/index.js!./tacit.min.css\", function() {\n\t\t\tvar newContent = require(\"!!./../../node_modules/css-loader/index.js!./tacit.min.css\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** bundle.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 4e3972f315b2b02c8a6e\n **/","require('./css/tacit.min.css')\nrequire('./app.html')\nriot.mount('app')\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/index.js\n ** module id = 0\n ** module chunks = 0\n **/","/* Riot v2.0.14, @license MIT, (c) 2015 Muut Inc. + contributors */\n\n;(function(window) {\n  // 'use strict' does not allow us to override the events properties https://github.com/muut/riotjs/blob/dev/lib/tag/update.js#L7-L10\n  // it leads to the following error on firefox \"setting a property that has only a getter\"\n  //'use strict'\n\n  var riot = { version: 'v2.0.14', settings: {} }\n\nriot.observable = function(el) {\n\n  el = el || {}\n\n  var callbacks = {},\n      _id = 0\n\n  el.on = function(events, fn) {\n    if (typeof fn == 'function') {\n      fn._id = typeof fn._id == 'undefined' ? _id++ : fn._id\n\n      events.replace(/\\S+/g, function(name, pos) {\n        (callbacks[name] = callbacks[name] || []).push(fn)\n        fn.typed = pos > 0\n      })\n    }\n    return el\n  }\n\n  el.off = function(events, fn) {\n    if (events == '*') callbacks = {}\n    else {\n      events.replace(/\\S+/g, function(name) {\n        if (fn) {\n          var arr = callbacks[name]\n          for (var i = 0, cb; (cb = arr && arr[i]); ++i) {\n            if (cb._id == fn._id) { arr.splice(i, 1); i-- }\n          }\n        } else {\n          callbacks[name] = []\n        }\n      })\n    }\n    return el\n  }\n\n  // only single event supported\n  el.one = function(name, fn) {\n    function on() {\n      el.off(name, on)\n      fn.apply(el, arguments)\n    }\n    return el.on(name, on)\n  }\n\n  el.trigger = function(name) {\n    var args = [].slice.call(arguments, 1),\n        fns = callbacks[name] || []\n\n    for (var i = 0, fn; (fn = fns[i]); ++i) {\n      if (!fn.busy) {\n        fn.busy = 1\n        fn.apply(el, fn.typed ? [name].concat(args) : args)\n        if (fns[i] !== fn) { i-- }\n        fn.busy = 0\n      }\n    }\n\n    if (callbacks.all && name != 'all') {\n      el.trigger.apply(el, ['all', name].concat(args))\n    }\n\n    return el\n  }\n\n  return el\n\n}\n;(function(riot, evt, window) {\n\n  // browsers only\n  if (!window) return\n\n  var loc = window.location,\n      fns = riot.observable(),\n      win = window,\n      current\n\n  function hash() {\n    return loc.href.split('#')[1] || ''\n  }\n\n  function parser(path) {\n    return path.split('/')\n  }\n\n  function emit(path) {\n    if (path.type) path = hash()\n\n    if (path != current) {\n      fns.trigger.apply(null, ['H'].concat(parser(path)))\n      current = path\n    }\n  }\n\n  var r = riot.route = function(arg) {\n    // string\n    if (arg[0]) {\n      loc.hash = arg\n      emit(arg)\n\n    // function\n    } else {\n      fns.on('H', arg)\n    }\n  }\n\n  r.exec = function(fn) {\n    fn.apply(null, parser(hash()))\n  }\n\n  r.parser = function(fn) {\n    parser = fn\n  }\n\n  win.addEventListener ? win.addEventListener(evt, emit, false) : win.attachEvent('on' + evt, emit)\n\n})(riot, 'hashchange', window)\n/*\n\n//// How it works?\n\n\nThree ways:\n\n1. Expressions: tmpl('{ value }', data).\n   Returns the result of evaluated expression as a raw object.\n\n2. Templates: tmpl('Hi { name } { surname }', data).\n   Returns a string with evaluated expressions.\n\n3. Filters: tmpl('{ show: !done, highlight: active }', data).\n   Returns a space separated list of trueish keys (mainly\n   used for setting html classes), e.g. \"show highlight\".\n\n\n// Template examples\n\ntmpl('{ title || \"Untitled\" }', data)\ntmpl('Results are { results ? \"ready\" : \"loading\" }', data)\ntmpl('Today is { new Date() }', data)\ntmpl('{ message.length > 140 && \"Message is too long\" }', data)\ntmpl('This item got { Math.round(rating) } stars', data)\ntmpl('<h1>{ title }</h1>{ body }', data)\n\n\n// Falsy expressions in templates\n\nIn templates (as opposed to single expressions) all falsy values\nexcept zero (undefined/null/false) will default to empty string:\n\ntmpl('{ undefined } - { false } - { null } - { 0 }', {})\n// will return: \" - - - 0\"\n\n*/\n\n\nvar brackets = (function(orig, s, b) {\n  return function(x) {\n\n    // make sure we use the current setting\n    s = riot.settings.brackets || orig\n    if (b != s) b = s.split(' ')\n\n    // if regexp given, rewrite it with current brackets (only if differ from default)\n    return x && x.test\n      ? s == orig\n        ? x : RegExp(x.source\n                      .replace(/\\{/g, b[0].replace(/(?=.)/g, '\\\\'))\n                      .replace(/\\}/g, b[1].replace(/(?=.)/g, '\\\\')),\n                    x.global ? 'g' : '')\n\n      // else, get specific bracket\n      : b[x]\n\n  }\n})('{ }')\n\n\nvar tmpl = (function() {\n\n  var cache = {},\n      re_vars = /(['\"\\/]).*?[^\\\\]\\1|\\.\\w*|\\w*:|\\b(?:(?:new|typeof|in|instanceof) |(?:this|true|false|null|undefined)\\b|function *\\()|([a-z_$]\\w*)/gi\n              // [ 1               ][ 2  ][ 3 ][ 4                                                                                  ][ 5       ]\n              // find variable names:\n              // 1. skip quoted strings and regexps: \"a b\", 'a b', 'a \\'b\\'', /a b/\n              // 2. skip object properties: .name\n              // 3. skip object literals: name:\n              // 4. skip javascript keywords\n              // 5. match var name\n\n  // build a template (or get it from cache), render with data\n  return function(str, data) {\n    return str && (cache[str] = cache[str] || tmpl(str))(data)\n  }\n\n\n  // create a template instance\n\n  function tmpl(s, p) {\n\n    // default template string to {}\n    s = (s || (brackets(0) + brackets(1)))\n\n      // temporarily convert \\{ and \\} to a non-character\n      .replace(brackets(/\\\\{/g), '\\uFFF0')\n      .replace(brackets(/\\\\}/g), '\\uFFF1')\n\n    // split string to expression and non-expresion parts\n    p = split(s, extract(s, brackets(/{/), brackets(/}/)))\n\n    return new Function('d', 'return ' + (\n\n      // is it a single expression or a template? i.e. {x} or <b>{x}</b>\n      !p[0] && !p[2] && !p[3]\n\n        // if expression, evaluate it\n        ? expr(p[1])\n\n        // if template, evaluate all expressions in it\n        : '[' + p.map(function(s, i) {\n\n            // is it an expression or a string (every second part is an expression)\n          return i % 2\n\n              // evaluate the expressions\n              ? expr(s, true)\n\n              // process string parts of the template:\n              : '\"' + s\n\n                  // preserve new lines\n                  .replace(/\\n/g, '\\\\n')\n\n                  // escape quotes\n                  .replace(/\"/g, '\\\\\"')\n\n                + '\"'\n\n        }).join(',') + '].join(\"\")'\n      )\n\n      // bring escaped { and } back\n      .replace(/\\uFFF0/g, brackets(0))\n      .replace(/\\uFFF1/g, brackets(1))\n\n    + ';')\n\n  }\n\n\n  // parse { ... } expression\n\n  function expr(s, n) {\n    s = s\n\n      // convert new lines to spaces\n      .replace(/\\n/g, ' ')\n\n      // trim whitespace, brackets, strip comments\n      .replace(brackets(/^[{ ]+|[ }]+$|\\/\\*.+?\\*\\//g), '')\n\n    // is it an object literal? i.e. { key : value }\n    return /^\\s*[\\w- \"']+ *:/.test(s)\n\n      // if object literal, return trueish keys\n      // e.g.: { show: isOpen(), done: item.done } -> \"show done\"\n      ? '[' +\n\n          // extract key:val pairs, ignoring any nested objects\n          extract(s,\n\n              // name part: name:, \"name\":, 'name':, name :\n              /[\"' ]*[\\w- ]+[\"' ]*:/,\n\n              // expression part: everything upto a comma followed by a name (see above) or end of line\n              /,(?=[\"' ]*[\\w- ]+[\"' ]*:)|}|$/\n              ).map(function(pair) {\n\n                // get key, val parts\n                return pair.replace(/^[ \"']*(.+?)[ \"']*: *(.+?),? *$/, function(_, k, v) {\n\n                  // wrap all conditional parts to ignore errors\n                  return v.replace(/[^&|=!><]+/g, wrap) + '?\"' + k + '\":\"\",'\n\n                })\n\n              }).join('')\n\n        + '].join(\" \").trim()'\n\n      // if js expression, evaluate as javascript\n      : wrap(s, n)\n\n  }\n\n\n  // execute js w/o breaking on errors or undefined vars\n\n  function wrap(s, nonull) {\n    s = s.trim()\n    return !s ? '' : '(function(v){try{v='\n\n        // prefix vars (name => data.name)\n        + (s.replace(re_vars, function(s, _, v) { return v ? '(d.'+v+'===undefined?'+(typeof window == 'undefined' ? 'global.' : 'window.')+v+':d.'+v+')' : s })\n\n          // break the expression if its empty (resulting in undefined value)\n          || 'x')\n\n      + '}finally{return '\n\n        // default to empty string for falsy values except zero\n        + (nonull === true ? '!v&&v!==0?\"\":v' : 'v')\n\n      + '}}).call(d)'\n  }\n\n\n  // split string by an array of substrings\n\n  function split(str, substrings) {\n    var parts = []\n    substrings.map(function(sub, i) {\n\n      // push matched expression and part before it\n      i = str.indexOf(sub)\n      parts.push(str.slice(0, i), sub)\n      str = str.slice(i + sub.length)\n    })\n\n    // push the remaining part\n    return parts.concat(str)\n  }\n\n\n  // match strings between opening and closing regexp, skipping any inner/nested matches\n\n  function extract(str, open, close) {\n\n    var start,\n        level = 0,\n        matches = [],\n        re = new RegExp('('+open.source+')|('+close.source+')', 'g')\n\n    str.replace(re, function(_, open, close, pos) {\n\n      // if outer inner bracket, mark position\n      if(!level && open) start = pos\n\n      // in(de)crease bracket level\n      level += open ? 1 : -1\n\n      // if outer closing bracket, grab the match\n      if(!level && close != null) matches.push(str.slice(start, pos+close.length))\n\n    })\n\n    return matches\n  }\n\n})()\n\n// { key, i in items} -> { key, i, items }\nfunction loopKeys(expr) {\n  var ret = { val: expr },\n      els = expr.split(/\\s+in\\s+/)\n\n  if (els[1]) {\n    ret.val = brackets(0) + els[1]\n    els = els[0].slice(brackets(0).length).trim().split(/,\\s*/)\n    ret.key = els[0]\n    ret.pos = els[1]\n  }\n\n  return ret\n}\n\nfunction mkitem(expr, key, val) {\n  var item = {}\n  item[expr.key] = key\n  if (expr.pos) item[expr.pos] = val\n  return item\n}\n\n\n/* Beware: heavy stuff */\nfunction _each(dom, parent, expr) {\n\n  remAttr(dom, 'each')\n\n  var template = dom.outerHTML,\n      prev = dom.previousSibling,\n      root = dom.parentNode,\n      rendered = [],\n      tags = [],\n      checksum\n\n  expr = loopKeys(expr)\n\n  function add(pos, item, tag) {\n    rendered.splice(pos, 0, item)\n    tags.splice(pos, 0, tag)\n  }\n\n  // clean template code\n  parent.one('update', function() {\n    root.removeChild(dom)\n\n  }).one('premount', function() {\n    if (root.stub) root = parent.root\n\n  }).on('update', function() {\n\n    var items = tmpl(expr.val, parent)\n    if (!items) return\n\n    // object loop. any changes cause full redraw\n    if (!Array.isArray(items)) {\n      var testsum = JSON.stringify(items)\n      if (testsum == checksum) return\n      checksum = testsum\n\n      // clear old items\n      each(tags, function(tag) { tag.unmount() })\n      rendered = []\n      tags = []\n\n      items = Object.keys(items).map(function(key) {\n        return mkitem(expr, key, items[key])\n      })\n\n    }\n\n    // unmount redundant\n    each(rendered, function(item) {\n      if (item instanceof Object) {\n        // skip existing items\n        if (items.indexOf(item) > -1) {\n          return\n        }\n      } else {\n        // find all non-objects\n        var newItems = arrFindEquals(items, item),\n            oldItems = arrFindEquals(rendered, item)\n\n        // if more or equal amount, no need to remove\n        if (newItems.length >= oldItems.length) {\n          return\n        }\n      }\n      var pos = rendered.indexOf(item),\n          tag = tags[pos]\n\n      if (tag) {\n        tag.unmount()\n        rendered.splice(pos, 1)\n        tags.splice(pos, 1)\n        // to let \"each\" know that this item is removed\n        return false\n      }\n\n    })\n\n    // mount new / reorder\n    var prev_base = [].indexOf.call(root.childNodes, prev) + 1\n    each(items, function(item, i) {\n\n      // start index search from position based on the current i\n      var pos = items.indexOf(item, i),\n          oldPos = rendered.indexOf(item, i)\n\n      // if not found, search backwards from current i position\n      pos < 0 && (pos = items.lastIndexOf(item, i))\n      oldPos < 0 && (oldPos = rendered.lastIndexOf(item, i))\n\n      if (!(item instanceof Object)) {\n        // find all non-objects\n        var newItems = arrFindEquals(items, item),\n            oldItems = arrFindEquals(rendered, item)\n\n        // if more, should mount one new\n        if (newItems.length > oldItems.length) {\n          oldPos = -1\n        }\n      }\n\n      // mount new\n      var nodes = root.childNodes\n      if (oldPos < 0) {\n        if (!checksum && expr.key) var _item = mkitem(expr, item, pos)\n\n        var tag = new Tag({ tmpl: template }, {\n          before: nodes[prev_base + pos],\n          parent: parent,\n          root: root,\n          item: _item || item\n        })\n\n        tag.mount()\n\n        add(pos, item, tag)\n        return true\n      }\n\n      // change pos value\n      if (expr.pos && tags[oldPos][expr.pos] != pos) {\n        tags[oldPos].one('update', function(item) {\n          item[expr.pos] = pos\n        })\n        tags[oldPos].update()\n      }\n\n      // reorder\n      if (pos != oldPos) {\n        root.insertBefore(nodes[prev_base + oldPos], nodes[prev_base + (pos > oldPos ? pos + 1 : pos)])\n        return add(pos, rendered.splice(oldPos, 1)[0], tags.splice(oldPos, 1)[0])\n      }\n\n    })\n\n    rendered = items.slice()\n\n  })\n\n}\n\n\nfunction parseNamedElements(root, parent, child_tags) {\n\n  walk(root, function(dom) {\n    if (dom.nodeType == 1) {\n\n      // custom child tag\n      var child = getTag(dom)\n\n      if (child && !dom.getAttribute('each')) {\n        var tag = new Tag(child, { root: dom, parent: parent }),\n            tagName = dom.getAttribute('name') || child.name,\n            cachedTag = parent.tags[tagName]\n\n        // if there are multiple children tags having the same name\n        if (cachedTag) {\n          // if the parent tags property is not yet an array\n          // create it adding the first cached tag\n          if (!Array.isArray(cachedTag))\n            parent.tags[tagName] = [cachedTag]\n          // add the new nested tag to the array\n          parent.tags[tagName].push(tag)\n        } else {\n          parent.tags[tagName] = tag\n        }\n\n        // empty the child node once we got its template\n        // to avoid that its children get compiled multiple times\n        dom.innerHTML = ''\n        child_tags.push(tag)\n      }\n\n      each(dom.attributes, function(attr) {\n        if (/^(name|id)$/.test(attr.name)) parent[attr.value] = dom\n      })\n    }\n\n  })\n\n}\n\nfunction parseExpressions(root, tag, expressions) {\n\n  function addExpr(dom, val, extra) {\n    if (val.indexOf(brackets(0)) >= 0) {\n      var expr = { dom: dom, expr: val }\n      expressions.push(extend(expr, extra))\n    }\n  }\n\n  walk(root, function(dom) {\n    var type = dom.nodeType\n\n    // text node\n    if (type == 3 && dom.parentNode.tagName != 'STYLE') addExpr(dom, dom.nodeValue)\n    if (type != 1) return\n\n    /* element */\n\n    // loop\n    var attr = dom.getAttribute('each')\n    if (attr) { _each(dom, tag, attr); return false }\n\n    // attribute expressions\n    each(dom.attributes, function(attr) {\n      var name = attr.name,\n          bool = name.split('__')[1]\n\n      addExpr(dom, attr.value, { attr: bool || name, bool: bool })\n      if (bool) { remAttr(dom, name); return false }\n\n    })\n\n    // skip custom tags\n    if (getTag(dom)) return false\n\n  })\n\n}\nfunction Tag(impl, conf) {\n\n  var self = riot.observable(this),\n      opts = inherit(conf.opts) || {},\n      dom = mkdom(impl.tmpl),\n      parent = conf.parent,\n      expressions = [],\n      child_tags = [],\n      root = conf.root,\n      item = conf.item,\n      fn = impl.fn,\n      attr = {},\n      loop_dom\n\n  if (fn && root.riot) return\n  root.riot = true\n\n  // create a unique id to this tag\n  // it could be handy to use it also to improve the virtual dom rendering speed\n  this._id = ~~(new Date().getTime() * Math.random())\n\n  extend(this, { parent: parent, root: root, opts: opts, tags: {} }, item)\n\n  // grab attributes\n  each(root.attributes, function(el) {\n    attr[el.name] = el.value\n  })\n\n  // options\n  function updateOpts(rem_attr) {\n    each(Object.keys(attr), function(name) {\n      opts[name] = tmpl(attr[name], parent || self)\n    })\n  }\n\n  this.update = function(data, init) {\n    extend(self, data, item)\n    updateOpts()\n    self.trigger('update', item)\n    update(expressions, self, item)\n    self.trigger('updated')\n  }\n\n  this.mount = function() {\n\n    updateOpts()\n\n    // initialiation\n    fn && fn.call(self, opts)\n\n    toggle(true)\n\n    // parse layout after init. fn may calculate args for nested custom tags\n    parseExpressions(dom, self, expressions)\n\n    self.update()\n\n    // internal use only, fixes #403\n    self.trigger('premount')\n\n    if (fn) {\n      while (dom.firstChild) root.appendChild(dom.firstChild)\n\n    } else {\n      loop_dom = dom.firstChild\n      root.insertBefore(loop_dom, conf.before || null) // null needed for IE8\n    }\n\n    if (root.stub) self.root = root = parent.root\n    self.trigger('mount')\n\n  }\n\n\n  this.unmount = function() {\n    var el = fn ? root : loop_dom,\n        p = el.parentNode,\n        // detect the tag name\n        tagName = root.tagName.toLowerCase()\n\n    if (p) {\n\n      if (parent) {\n        // remove this tag from the parent tags object\n        // if there are multiple nested tags with same name..\n        // remove this element form the array\n        if (Array.isArray(parent.tags[tagName])) {\n          each(parent.tags[tagName], function(tag, i) {\n            if (tag._id == self._id)\n              parent.tags[tagName].splice(i, 1)\n          })\n        } else\n          // otherwise just delete the tag instance\n          delete parent.tags[tagName]\n\n        p.removeChild(el)\n      } else {\n        while (el.firstChild) el.removeChild(el.firstChild)\n        p.removeChild(el)\n      }\n\n    }\n\n    self.trigger('unmount')\n    toggle()\n    self.off('*')\n    delete root.riot\n\n  }\n\n  function toggle(is_mount) {\n\n    // mount/unmount children\n    each(child_tags, function(child) { child[is_mount ? 'mount' : 'unmount']() })\n\n    // listen/unlisten parent (events flow one way from parent to children)\n    if (parent) {\n      var evt = is_mount ? 'on' : 'off'\n      parent[evt]('update', self.update)[evt]('unmount', self.unmount)\n    }\n  }\n\n  // named elements available for fn\n  parseNamedElements(dom, this, child_tags)\n\n\n}\n\nfunction setEventHandler(name, handler, dom, tag, item) {\n\n  dom[name] = function(e) {\n\n    // cross browser event fix\n    e = e || window.event\n    e.which = e.which || e.charCode || e.keyCode\n    e.target = e.target || e.srcElement\n    e.currentTarget = dom\n    e.item = item\n\n    // prevent default behaviour (by default)\n    if (handler.call(tag, e) !== true && !/radio|check/.test(dom.type)) {\n      e.preventDefault && e.preventDefault()\n      e.returnValue = false\n    }\n\n    var el = item ? tag.parent : tag\n    el.update()\n\n  }\n\n}\n\n// used by if- attribute\nfunction insertTo(root, node, before) {\n  if (root) {\n    root.insertBefore(before, node)\n    root.removeChild(node)\n  }\n}\n\n// item = currently looped item\nfunction update(expressions, tag, item) {\n\n  each(expressions, function(expr) {\n\n    var dom = expr.dom,\n        attr_name = expr.attr,\n        value = tmpl(expr.expr, tag),\n        parent = expr.dom.parentNode\n\n    if (value == null) value = ''\n\n    // leave out riot- prefixes from strings inside textarea\n    if (parent && parent.tagName == 'TEXTAREA') value = value.replace(/riot-/g, '')\n\n    // no change\n    if (expr.value === value) return\n    expr.value = value\n\n    // text node\n    if (!attr_name) return dom.nodeValue = value\n\n    // remove original attribute\n    remAttr(dom, attr_name)\n\n    // event handler\n    if (typeof value == 'function') {\n      setEventHandler(attr_name, value, dom, tag, item)\n\n    // if- conditional\n    } else if (attr_name == 'if') {\n      var stub = expr.stub\n\n      // add to DOM\n      if (value) {\n        stub && insertTo(stub.parentNode, stub, dom)\n\n      // remove from DOM\n      } else {\n        stub = expr.stub = stub || document.createTextNode('')\n        insertTo(dom.parentNode, dom, stub)\n      }\n\n    // show / hide\n    } else if (/^(show|hide)$/.test(attr_name)) {\n      if (attr_name == 'hide') value = !value\n      dom.style.display = value ? '' : 'none'\n\n    // field value\n    } else if (attr_name == 'value') {\n      dom.value = value\n\n    // <img src=\"{ expr }\">\n    } else if (attr_name.slice(0, 5) == 'riot-') {\n      attr_name = attr_name.slice(5)\n      value ? dom.setAttribute(attr_name, value) : remAttr(dom, attr_name)\n\n    } else {\n      if (expr.bool) {\n        dom[attr_name] = value\n        if (!value) return\n        value = attr_name\n      }\n\n      if (typeof value != 'object') dom.setAttribute(attr_name, value)\n\n    }\n\n  })\n\n}\nfunction each(els, fn) {\n  for (var i = 0, len = (els || []).length, el; i < len; i++) {\n    el = els[i]\n    // return false -> remove current item during loop\n    if (el != null && fn(el, i) === false) i--\n  }\n  return els\n}\n\nfunction remAttr(dom, name) {\n  dom.removeAttribute(name)\n}\n\n// max 2 from objects allowed\nfunction extend(obj, from, from2) {\n  from && each(Object.keys(from), function(key) {\n    obj[key] = from[key]\n  })\n  return from2 ? extend(obj, from2) : obj\n}\n\nfunction mkdom(template) {\n  var tag_name = template.trim().slice(1, 3).toLowerCase(),\n      root_tag = /td|th/.test(tag_name) ? 'tr' : tag_name == 'tr' ? 'tbody' : 'div',\n      el = document.createElement(root_tag)\n\n  el.stub = true\n  el.innerHTML = template\n  return el\n}\n\nfunction walk(dom, fn) {\n  if (dom) {\n    if (fn(dom) === false) walk(dom.nextSibling, fn)\n    else {\n      dom = dom.firstChild\n\n      while (dom) {\n        walk(dom, fn)\n        dom = dom.nextSibling\n      }\n    }\n  }\n}\n\nfunction arrDiff(arr1, arr2) {\n  return arr1.filter(function(el) {\n    return arr2.indexOf(el) < 0\n  })\n}\n\nfunction arrFindEquals(arr, el) {\n  return arr.filter(function (_el) {\n    return _el === el\n  })\n}\n\nfunction inherit(parent) {\n  function Child() {}\n  Child.prototype = parent\n  return new Child()\n}\n\n/*\n Virtual dom is an array of custom tags on the document.\n Updates and unmounts propagate downwards from parent to children.\n*/\n\nvar virtual_dom = [],\n    tag_impl = {}\n\n\nfunction getTag(dom) {\n  return tag_impl[dom.tagName.toLowerCase()]\n}\n\nfunction injectStyle(css) {\n  var node = document.createElement('style')\n  node.innerHTML = css\n  document.head.appendChild(node)\n}\n\nfunction mountTo(root, tagName, opts) {\n  var tag = tag_impl[tagName]\n\n  if (tag && root) tag = new Tag(tag, { root: root, opts: opts })\n\n  if (tag && tag.mount) {\n    tag.mount()\n    virtual_dom.push(tag)\n    return tag.on('unmount', function() {\n      virtual_dom.splice(virtual_dom.indexOf(tag), 1)\n    })\n  }\n\n}\n\nriot.tag = function(name, html, css, fn) {\n  if (typeof css == 'function') fn = css\n  else if (css) injectStyle(css)\n  tag_impl[name] = { name: name, tmpl: html, fn: fn }\n  return name\n}\n\nriot.mount = function(selector, tagName, opts) {\n  if (selector == '*') selector = Object.keys(tag_impl).join(', ')\n  if (typeof tagName == 'object') { opts = tagName; tagName = 0 }\n\n  var tags = []\n\n  function push(root) {\n    var name = tagName || root.tagName.toLowerCase(),\n        tag = mountTo(root, name, opts)\n\n    if (tag) tags.push(tag)\n  }\n\n  // DOM node\n  if (selector.tagName) {\n    push(selector)\n    return tags[0]\n\n  // selector or NodeList\n  } else {\n    each(typeof selector == 'string' ? document.querySelectorAll(selector) : selector, push)\n    return tags\n  }\n\n}\n\n// update everything\nriot.update = function() {\n  return each(virtual_dom, function(tag) {\n    tag.update()\n  })\n}\n\n// @deprecated\nriot.mountTo = riot.mount\n\n\n\n  // share methods for other riot parts, e.g. compiler\n  riot.util = { brackets: brackets, tmpl: tmpl }\n\n  // support CommonJS, AMD & browser\n  if (typeof exports === 'object')\n    module.exports = riot\n  else if (typeof define === 'function' && define.amd)\n    define(function() { return riot })\n  else\n    window.riot = riot\n\n})(typeof window != 'undefined' ? window : undefined);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/riot/riot.js\n ** module id = 1\n ** module chunks = 0\n **/","exports = module.exports = require(\"./../../node_modules/css-loader/lib/css-base.js\")();\nexports.push([module.id, \"label,table{display:block}h1,h4,h5,h6{font-size:36px}b,h1,strong{font-weight:500}*,pre code{line-height:29.7px}*,h3{font-size:18px}*,pre code{padding:0;border:0}section,table{max-width:100%}footer,h1,h4,h5,h6{margin-top:36px}th{font-weight:600}td,th{border-bottom:1.08px solid #ccc;padding:14.85px 18px}thead th{border-bottom-width:2.16px;padding-bottom:6.3px}table{overflow-x:auto}button,input,select,textarea{display:block;padding:9.9px}label{margin-bottom:14.76px}button,input[type=submit],input[type=reset]{background:#b3b3b3;border-radius:3.6px;color:#fff;cursor:pointer;display:inline;margin-bottom:18px;margin-right:7.2px;padding:6.53px 23.4px;text-align:center}button:hover,input[type=submit]:hover,input[type=reset]:hover{background:#a6a6a6;color:#bfbfbf}button[type=submit],input[type=submit]{background:#367ac3;color:#fff}button[type=submit]:hover,input[type=submit]:hover{background:#255587;color:#bfbfbf}input[type=date],input[type=month],input[type=color],input[type=time],input[type=search],input[type=range],input[type=file],input[type=datetime-local],input[type=text],input[type=password],input[type=email],input[type=url],input[type=phone],input[type=tel],input[type=number],input[type=datetime],select,textarea{border:1px solid #ccc;margin-bottom:18px;padding:5.4px 6.3px}input[type=checkbox]{float:left;line-height:36px;margin-right:9px;margin-top:8.1px}code,kbd,output,pre,samp,var{font-family:Menlo,Monaco,Consolas,\\\"Courier New\\\",monospace;font-size:16.2px}pre{border-left:1.8px solid #96bbe2;line-height:25.2px;margin-top:29.7px;overflow:auto;padding-left:18px}pre code{background:0 0}code{background:#ededed;border:1.8px solid #ccc;border-radius:3.6px;display:inline-block;line-height:18px;padding:3px 6px 2px}h1,h2,h3,h4,h5,h6{color:#000}h1{margin-bottom:18px}h2{font-size:25.2px;font-weight:400;margin-bottom:18px;margin-top:27px}h3{margin-bottom:18px;margin-top:21.6px}h4,h5,h6{margin-bottom:18px}a{color:#367ac3;text-decoration:none}a:hover{text-decoration:underline}hr{border-bottom:1px solid #ccc}small{font-size:15.3px}em,i{font-style:italic}*{border-collapse:separate;border-spacing:0;box-sizing:border-box;font-family:\\\"Helvetica Neue\\\",Helvetica,Arial,sans-serif;font-stretch:normal;font-style:normal;font-weight:300;margin:0;outline:0;text-align:left;vertical-align:baseline}nav,nav ul{text-align:center}body{background:#f5f5f5;color:#1a1a1a;padding:36px}address,blockquote,dl,fieldset,figure,form,hr,ol,p,pre,table,ul{margin-bottom:29.7px}section{margin-left:auto;margin-right:auto;width:900px}article{background:#fff;border:1.8px solid #d9d9d9;border-radius:7.2px;padding:43.2px}header{margin-bottom:36px}nav ul{list-style:none}nav ul li{display:inline;margin-left:9px;margin-right:9px}@media (max-width:767px){article,body{padding:18px}article{border-radius:0;margin:-18px}input,select,textarea{max-width:100%}fieldset{min-width:0}@-moz-document url-prefix(){fieldset{display:table-cell}}section{width:auto}}\", \"\"]);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-loader!./src/css/tacit.min.css\n ** module id = 2\n ** module chunks = 0\n **/","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\n// \r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join(\"\");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === \"string\")\r\n\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === \"number\")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(var i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-loader/lib/css-base.js\n ** module id = 3\n ** module chunks = 0\n **/","riot.tag('app', '<div>test riotjs12!</div>', function(opts) {\n\n\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/app.html\n ** module id = 4\n ** module chunks = 0\n **/","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\nvar stylesInDom = {},\r\n\tmemoize = function(fn) {\r\n\t\tvar memo;\r\n\t\treturn function () {\r\n\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\r\n\t\t\treturn memo;\r\n\t\t};\r\n\t},\r\n\tisOldIE = memoize(function() {\r\n\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\r\n\t}),\r\n\tgetHeadElement = memoize(function () {\r\n\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\r\n\t}),\r\n\tsingletonElement = null,\r\n\tsingletonCounter = 0;\r\n\r\nmodule.exports = function(list, options) {\r\n\tif(typeof DEBUG !== \"undefined\" && DEBUG) {\r\n\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\r\n\t}\r\n\r\n\toptions = options || {};\r\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\r\n\t// tags it will allow on a page\r\n\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\r\n\r\n\tvar styles = listToStyles(list);\r\n\taddStylesToDom(styles, options);\r\n\r\n\treturn function update(newList) {\r\n\t\tvar mayRemove = [];\r\n\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\tvar item = styles[i];\r\n\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\tdomStyle.refs--;\r\n\t\t\tmayRemove.push(domStyle);\r\n\t\t}\r\n\t\tif(newList) {\r\n\t\t\tvar newStyles = listToStyles(newList);\r\n\t\t\taddStylesToDom(newStyles, options);\r\n\t\t}\r\n\t\tfor(var i = 0; i < mayRemove.length; i++) {\r\n\t\t\tvar domStyle = mayRemove[i];\r\n\t\t\tif(domStyle.refs === 0) {\r\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\r\n\t\t\t\t\tdomStyle.parts[j]();\r\n\t\t\t\tdelete stylesInDom[domStyle.id];\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n}\r\n\r\nfunction addStylesToDom(styles, options) {\r\n\tfor(var i = 0; i < styles.length; i++) {\r\n\t\tvar item = styles[i];\r\n\t\tvar domStyle = stylesInDom[item.id];\r\n\t\tif(domStyle) {\r\n\t\t\tdomStyle.refs++;\r\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\r\n\t\t\t}\r\n\t\t\tfor(; j < item.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tvar parts = [];\r\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\r\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction listToStyles(list) {\r\n\tvar styles = [];\r\n\tvar newStyles = {};\r\n\tfor(var i = 0; i < list.length; i++) {\r\n\t\tvar item = list[i];\r\n\t\tvar id = item[0];\r\n\t\tvar css = item[1];\r\n\t\tvar media = item[2];\r\n\t\tvar sourceMap = item[3];\r\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\r\n\t\tif(!newStyles[id])\r\n\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\r\n\t\telse\r\n\t\t\tnewStyles[id].parts.push(part);\r\n\t}\r\n\treturn styles;\r\n}\r\n\r\nfunction createStyleElement() {\r\n\tvar styleElement = document.createElement(\"style\");\r\n\tvar head = getHeadElement();\r\n\tstyleElement.type = \"text/css\";\r\n\thead.appendChild(styleElement);\r\n\treturn styleElement;\r\n}\r\n\r\nfunction createLinkElement() {\r\n\tvar linkElement = document.createElement(\"link\");\r\n\tvar head = getHeadElement();\r\n\tlinkElement.rel = \"stylesheet\";\r\n\thead.appendChild(linkElement);\r\n\treturn linkElement;\r\n}\r\n\r\nfunction addStyle(obj, options) {\r\n\tvar styleElement, update, remove;\r\n\r\n\tif (options.singleton) {\r\n\t\tvar styleIndex = singletonCounter++;\r\n\t\tstyleElement = singletonElement || (singletonElement = createStyleElement());\r\n\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\r\n\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\r\n\t} else if(obj.sourceMap &&\r\n\t\ttypeof URL === \"function\" &&\r\n\t\ttypeof URL.createObjectURL === \"function\" &&\r\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\r\n\t\ttypeof Blob === \"function\" &&\r\n\t\ttypeof btoa === \"function\") {\r\n\t\tstyleElement = createLinkElement();\r\n\t\tupdate = updateLink.bind(null, styleElement);\r\n\t\tremove = function() {\r\n\t\t\tstyleElement.parentNode.removeChild(styleElement);\r\n\t\t\tif(styleElement.href)\r\n\t\t\t\tURL.revokeObjectURL(styleElement.href);\r\n\t\t};\r\n\t} else {\r\n\t\tstyleElement = createStyleElement();\r\n\t\tupdate = applyToTag.bind(null, styleElement);\r\n\t\tremove = function() {\r\n\t\t\tstyleElement.parentNode.removeChild(styleElement);\r\n\t\t};\r\n\t}\r\n\r\n\tupdate(obj);\r\n\r\n\treturn function updateStyle(newObj) {\r\n\t\tif(newObj) {\r\n\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\r\n\t\t\t\treturn;\r\n\t\t\tupdate(obj = newObj);\r\n\t\t} else {\r\n\t\t\tremove();\r\n\t\t}\r\n\t};\r\n}\r\n\r\nvar replaceText = (function () {\r\n\tvar textStore = [];\r\n\r\n\treturn function (index, replacement) {\r\n\t\ttextStore[index] = replacement;\r\n\t\treturn textStore.filter(Boolean).join('\\n');\r\n\t};\r\n})();\r\n\r\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\r\n\tvar css = remove ? \"\" : obj.css;\r\n\r\n\tif (styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\r\n\t} else {\r\n\t\tvar cssNode = document.createTextNode(css);\r\n\t\tvar childNodes = styleElement.childNodes;\r\n\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\r\n\t\tif (childNodes.length) {\r\n\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\r\n\t\t} else {\r\n\t\t\tstyleElement.appendChild(cssNode);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction applyToTag(styleElement, obj) {\r\n\tvar css = obj.css;\r\n\tvar media = obj.media;\r\n\tvar sourceMap = obj.sourceMap;\r\n\r\n\tif(media) {\r\n\t\tstyleElement.setAttribute(\"media\", media)\r\n\t}\r\n\r\n\tif(styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = css;\r\n\t} else {\r\n\t\twhile(styleElement.firstChild) {\r\n\t\t\tstyleElement.removeChild(styleElement.firstChild);\r\n\t\t}\r\n\t\tstyleElement.appendChild(document.createTextNode(css));\r\n\t}\r\n}\r\n\r\nfunction updateLink(linkElement, obj) {\r\n\tvar css = obj.css;\r\n\tvar media = obj.media;\r\n\tvar sourceMap = obj.sourceMap;\r\n\r\n\tif(sourceMap) {\r\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(JSON.stringify(sourceMap)) + \" */\";\r\n\t}\r\n\r\n\tvar blob = new Blob([css], { type: \"text/css\" });\r\n\r\n\tvar oldSrc = linkElement.href;\r\n\r\n\tlinkElement.href = URL.createObjectURL(blob);\r\n\r\n\tif(oldSrc)\r\n\t\tURL.revokeObjectURL(oldSrc);\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/style-loader/addStyles.js\n ** module id = 5\n ** module chunks = 0\n **/","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../node_modules/css-loader/index.js!./tacit.min.css\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../node_modules/style-loader/addStyles.js\")(content, {});\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tmodule.hot.accept(\"!!./../../node_modules/css-loader/index.js!./tacit.min.css\", function() {\n\t\tvar newContent = require(\"!!./../../node_modules/css-loader/index.js!./tacit.min.css\");\n\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\tupdate(newContent);\n\t});\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/css/tacit.min.css\n ** module id = 6\n ** module chunks = 0\n **/"],"sourceRoot":""}